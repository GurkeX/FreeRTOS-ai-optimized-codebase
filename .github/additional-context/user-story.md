# User Story: Developer Profile

## Background

**Experience:** 1.5 years programming - built embedded systems with FreeRTOS (C++) including fully automatic growbox with external sensors

**Current Project:** Developing Obsidian plugins for family construction business - material management system for field workers on tablets

**Transition:** Moving from embedded systems/C++ to JavaScript/TypeScript/React ecosystem for Obsidian plugin development

## What I Know

### Strong Foundations

-   **C++ & OOP:** Classes, inheritance, memory management (pointers, references, const correctness), design patterns (singleton, observer)
-   **Systems Programming:** OS concepts (copy-on-write, threading), data structures (complexity analysis, hash maps, sets), real-time systems
-   **Other Languages:** Python (basic), Dart/Flutter (extensive - understand mobile app architecture)

### Currently Learning

-   JavaScript/TypeScript syntax and idioms (new to me)
-   React, hooks (useEffect, useState), component lifecycle
-   State management (Zustand, Immer) - immutability in JS context
-   Obsidian API and plugin architecture
-   Web development patterns (no prior Node.js/frontend experience)

### Knowledge Gaps (Don't Assume I Know)

-   NPM ecosystem and package management conventions
-   JavaScript module systems (CommonJS vs ES modules)
-   React optimizations (memo, useMemo, useCallback)
-   Web-specific concepts (DOM APIs, browser quirks)
-   Frontend build tools beyond basic usage

## How I Learn

### Learning Pace & Style

-   **Quick to grasp concepts** but need time to internalize before moving forward
-   **Practical, example-driven:** Show me "how to use" first, then explain "why it works"
-   **Deep understanding focus:** Need to understand inner workings to confidently debug and extend code
-   **Interactive learning:** Learn by explaining concepts back in my own words

### Effective Analogies for Me

-   **C++ comparisons:** Memory management, const correctness → immutability, references vs values, class patterns
-   **Embedded systems:** Event loops → event callbacks, state machines, resource management, interrupt handlers
-   **Performance:** Algorithm complexity (O(n)), data structure trade-offs

### Analogies to Avoid

-   Pure functional programming concepts (limited experience)
-   Web-specific jargon without context
-   Assuming JavaScript ecosystem knowledge

## Communication Preferences

### What Works

-   Start with **WHY** a pattern exists before showing HOW
-   Use **C++ analogies** to connect new concepts to familiar ones
-   Show **real code from the actual project** (not generic examples)
-   Break explanations into **small, digestible chunks** (5-7 parts max)
-   **Wait for my response** before continuing - I'm quick but need processing time
-   Start feedback with **what I got right**, then gently correct misconceptions
-   Use encouraging language: "Great insight!", "You're on the right track!"

### What Doesn't Work

-   Multiple choice questions (prevents me from explaining my reasoning)
-   Yes/no questions (doesn't reveal understanding depth)
-   Moving forward without checking if I understood previous concept
-   Assuming I know web-specific concepts without explanation
-   Rushing - I'm fast but need moment to digest
-   Condescending corrections or "Obviously..." statements

## My Goals

**Primary:** Understand this codebase deeply enough to confidently debug, extend, and optimize for real-world use (construction site tablets, 500-1000+ materials)

**Success Criteria:**

1. Can explain how features work in my own words
2. Can predict what happens when code is modified
3. Can debug by understanding root causes (not symptoms)
4. Can make informed architectural decisions

**Context:** Building production tools for non-technical users (construction workers) in challenging field conditions - need pragmatic solutions that actually work, not just theoretical understanding.

---

**In Summary:** Treat me as a smart, quick learner with strong C++/embedded foundations transitioning to web development. I need practical examples with C++ analogies, patient pacing to digest concepts, and deep explanations so I can confidently build production tools for real users.
